C51 COMPILER V9.60.7.0   ALARM                                                             05/29/2024 21:24:33 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ALARM
OBJECT MODULE PLACED IN .\Objects\alarm.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE alarm.c LARGE WARNINGLEVEL(1) OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND
                    - PRINT(.\Listings\alarm.lst) TABS(2) OBJECT(.\Objects\alarm.obj)

line level    source

   1          #include "alarm.h"
   2          #include "oled.h"
   3          #include "ds1302.h"
   4          #include "keyscan.h"
   5          #include "delay.h"
   6          #include "mp3.h"
   7          
   8          extern Alarm alarm;
   9          //Alarm alarm_delay;
  10          
  11          void alarm_init(){
  12   1        alarm.hour = get_integer_hour();
  13   1        alarm.minute = get_integer_minute();
  14   1        alarm.ringtone = 1;
  15   1        alarm.enable = 0;
  16   1      }
  17          
  18          char adjust_12(char month_num){
  19   1        if(month_num > 12) month_num = 1;
  20   1        return month_num;
  21   1      }
  22          
  23          char adjust_30(uint year_num, char month_num, char day_num){
  24   1        if(month_num == 2){
  25   2          if(isLeapYear(year_num)){
  26   3            if(day_num > 29) day_num = 1;
  27   3          }
  28   2          else {
  29   3            if(day_num > 28) day_num = 1;
  30   3          }
  31   2        }
  32   1        else if(month_num == 4 || month_num == 6 || month_num == 9 || month_num == 11){
  33   2          if(day_num > 30) day_num = 1;
  34   2        }
  35   1        else{
  36   2          if(day_num > 31) day_num = 1;
  37   2        }
  38   1        return day_num;
  39   1      }
  40          
  41          char adjust_24(char hour_num){
  42   1        if(hour_num >= 24) hour_num = 0;
  43   1        return hour_num;
  44   1      }
  45          
  46          char adjust_60(char minute_num){
  47   1        if(minute_num >= 60) minute_num = 0;
  48   1        return minute_num;
  49   1      }
  50          
  51          void page_alarm(){
  52   1        char title[] = "Alarm1";
  53   1        char alarm_hour[3] = "00";
  54   1        char alarm_minute[3] = "00";
C51 COMPILER V9.60.7.0   ALARM                                                             05/29/2024 21:24:33 PAGE 2   

  55   1        char alarm_music[] = "Music ";
  56   1        uchar step = 1;
  57   1        Alarm alarm_original;
  58   1        OLED_Clear();
  59   1        alarm_original = alarm;
  60   1        double_digit_to_string(alarm.hour, alarm_hour);
  61   1        double_digit_to_string(alarm.minute, alarm_minute);
  62   1        alarm_music[5] = Char(alarm.ringtone);
  63   1        while(1){
  64   2          OLED_ShowString(32,0,title,16);
  65   2          if(step == 1) OLED_ShowString_Reverse(32,2,alarm_hour,16);
  66   2          else OLED_ShowString(32,2,alarm_hour,16);
  67   2          OLED_ShowChar(50,2,':',16);
  68   2          if(step == 2) OLED_ShowString_Reverse(56,2,alarm_minute,16);
  69   2          else OLED_ShowString(56,2,alarm_minute,16);
  70   2          if(step == 3) OLED_ShowString_Reverse(32,4,alarm_music,16);
  71   2          else OLED_ShowString(32,4,alarm_music,16);
  72   2          if(step == 4){
  73   3            if(alarm.enable) OLED_ShowString_Reverse(32,6,"Enabled",16);
  74   3            else OLED_ShowString_Reverse(32,6,"Disable",16);
  75   3          }
  76   2          else{
  77   3            if(alarm.enable) OLED_ShowString(32,6,"Enabled",16);
  78   3            else OLED_ShowString(32,6,"Disable",16);
  79   3          }
  80   2          if(getKey() == 1){
  81   3            switch(step){
  82   4              case 1: {
  83   5                alarm.hour++;
  84   5                alarm.hour = adjust_24(alarm.hour);
  85   5                double_digit_to_string(alarm.hour, alarm_hour);
  86   5                break;
  87   5              }
  88   4              case 2: {
  89   5                alarm.minute++;
  90   5                alarm.minute = adjust_60(alarm.minute);
  91   5                double_digit_to_string(alarm.minute, alarm_minute);
  92   5                break;
  93   5              }
  94   4              case 3: {
  95   5                alarm.ringtone++;
  96   5                if(alarm.ringtone >= 10) alarm.ringtone = 1;
  97   5                alarm_music[5] = Char(alarm.ringtone);
  98   5                break;
  99   5              }
 100   4              case 4: {
 101   5                if(alarm.enable) alarm.enable = 0;
 102   5                else alarm.enable = 1;
 103   5                break;
 104   5              }
 105   4              default: break;
 106   4            }
 107   3          }
 108   2          else if(getKey() == 2){
 109   3            step++;
 110   3            if(step > 4) step = 1;
 111   3          }
 112   2          else if(getKey() == 3){
 113   3            OLED_Clear();
 114   3            alarm = alarm_original;
 115   3            break;
 116   3          }
C51 COMPILER V9.60.7.0   ALARM                                                             05/29/2024 21:24:33 PAGE 3   

 117   2          else if(getKey() == 4){
 118   3            OLED_Clear();
 119   3            OLED_ShowString(32,2,"Saved!",16);
 120   3            delay_ms(2000);
 121   3            OLED_Clear();
 122   3            break;
 123   3          }
 124   2        }
 125   1      }
 126          
 127          void alarm_tick_tock(){
 128   1        if(alarm.enable && get_integer_hour() == alarm.hour && get_integer_minute() == alarm.minute) page_ring();
 129   1      }
 130          
 131          void page_ring(){
 132   1        OLED_Clear();
 133   1        OLED_ShowString(0,2,"Alarm going off",16);
 134   1        set_single_loop(1);
 135   1        playmusic(alarm.ringtone);
 136   1        while(1){
 137   2          if(getKey()){
 138   3            alarm.enable = 0;
 139   3            stopmusic();
 140   3            set_single_loop(0);
 141   3            OLED_Clear();
 142   3            break;
 143   3          }
 144   2        }
 145   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    808    ----
   CONSTANT SIZE    =     59    ----
   XDATA SIZE       =   ----      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
